from flask import Flask, render_template, url_for, requestimport numpy as npimport pandas as pdapp = Flask(__name__)@app.route("/")@app.route("/home")@app.route("/rank")def rank_based():    return render_template('home.html')@app.route("/knowledge", methods=['GET', 'POST'])def knowledge_rs():    '''    Knowledge-Based Recommender System    Return: Top 10 movies (IMDB Formula) according to user's preferences        '''    try:        error = None        final = None        df = pd.read_csv('genres_df2.csv')        def rating_score(df, c = 3.5020, m = 84.0):            '''            Calculating a weighted rating score that considers both number_of_votes and average_rating per movie                        Input: a movies dataframe df, a threshold for number of ratings q                        return: the weighted rating score for each movie            '''            v = df.rating_count # number of ratings per movie            r = df.rating_average # average rating per movie                        return round((v * r / (v + m)) + (m * c / (v + m)), 2) # IMBD weighted rating formula                genres_list = df.genre.unique().tolist()[:-1]        genres = request.form["genreslist"].lower().split()        f_year = int(request.form['early'])        assert 1902 <= f_year <= 2018        l_year = int(request.form['last'])        assert f_year <= l_year <= 2018        # filter the datframe based on user's prefrences        knowledge_df = df.query('genre == @genres & year >= @f_year & year <= @l_year')                if knowledge_df.empty:            return render_template('knowledge.html', input_success = False,                            error="Sorry, no movies were released in the chosen years/genres.")        else:            ck = knowledge_df.rating_average.mean()            mk = knowledge_df.rating_count.quantile(0.75)            knowledge_df = knowledge_df[knowledge_df.rating_count >= mk]                    #calculating weighted score for each movie            knowledge_df['score'] = knowledge_df.apply(rating_score, args = (mk, ck), axis = 1)                    knowledge_df = knowledge_df.sort_values('score', ascending = False).drop_duplicates(subset = 'title')            knowledge_df = knowledge_df[['title', 'genre', 'year']].head(15)                    return render_template('knowledge.html', tables=[knowledge_df.to_html(classes='data', index = False)], titles=knowledge_df.columns.values, input_success = True)                except (ValueError, KeyError, AssertionError):        return render_template('knowledge.html', input_success = False,                                error = "Please note that years (1902, 2018) \n && genres: {}".format(genres_list))        @app.route("/content", methods=['GET', 'POST'])def content_RS():    '''    Content-Based Recommender System            Return: top 10 most similar movies to the movie in interest    '''           try:        error = None        final = None        title = request.form["Movie"].lower()        df = pd.read_csv('content_df.csv')        indices = pd.read_csv('indices.csv', index_col = 'title', squeeze = True)        sim = np.load('cosine_sim.npy')        # Obtain the index of the movie that matches the title        idx = indices[title]        # Get the pairwsie similarity scores of all movies with that movie        sim_scores = list(enumerate(sim[idx]))        # Sort the movies based on the cosine similarity scores        sim_scores = sorted(sim_scores, key = lambda x: x[1], reverse = True)        # Get the scores of the 10 most similar movies.        sim_scores = sim_scores[1:11]        # Get the movie indices        movie_indices = [i[0] for i in sim_scores]        df = df['title'].iloc[movie_indices].to_frame()        return render_template('content.html', tables=[df.to_html(classes='data', index = False)], titles=df.columns.values, input_success = True, title = title)    except KeyError:        return render_template('content.html', input_success = False, error="Please enter movie EXACTLY as in IMDB, including released year i.e. 'Aladdin (1992)'")if __name__ == '__main__':    app.run(debug = True)